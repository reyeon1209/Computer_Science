## **THEMA 85 소프트웨어 개발 생명주기(SDLC)**
### 1. 계획
#### (1) 비용계획
- LOC, COCOMO, 기능점수

#### (2) 일정계획
- WBS, CPM, PERT, 간트차트

### 2. 분석
#### (1) 기능적/비기능적 요구

#### (2) 구조적 분석도구
- 자료흐름도, 자료사전, 소단위 명세서

#### (3) 객체지향적 분석도구
- Use-Case Diagram

### 3. 설계
#### (1) 상위설계/하위설계
- 상위설계: 아키텍처 설계, 디자인 패턴
- 하위설계: 모듈 설계 (결합도, 응집력)

#### (2) 구조적 설계도구
- 구조도, HIPO, NS차트

#### (3) 객체지향적 설계도구 (UML)
- Sequence Diagram, Class Diagram, State Diagram

### 4. 구현
#### (1) 리팩토링

### 5. 테스트
#### (1) 정적테스트/동적테스트
- 동적테스트: 블랙박스 테스트, 화이트박스 테스트

#### (2)
단위 테스트 → 통합 테스트 → 시스템 테스트 → 인수 테스트  
+) JUnit: 단위 테스트 도구

### 6. 유지보수
- 수정 유지보수, 완전 유지보수, 적응 유지보수, 예방 유지보수
- 회귀 테스트



## **THEMA 86 소프트웨어 개발 방법론**
### 1. 폭포수 모형
### 2. 프로토타입 모형
### 3. 나선형 모형
- 대규모 프로젝트
- 계획 및 정의 → 위험 분석 → 개발(공학) → 고객 평가 단계를 반복

### 4. V 모형
- 요구분석 → 시스템설계 → 세부설계 → 구현 → 단위테스트 → 통합테스트 → 시스템테스트 → 인수/유지보수

### 5. 통합 프로세스 (UP: Unified Process)
#### (1) 특징
- 객체지향 소프트웨어 개발 방법론
- 반복적이고 점진적인 개발 방법
- use case 기반
- 아키텍처 중심의 개발 지향
- 위험 관리 중시

#### (2) 개발 활동
||||
|---|---|---|
|도입(Inception)|소프트웨어 개발에 관련된 사람들과 개발을 준비하는 단계|요구사항 관련 작업의 비중이 높다.|
|상세(Elaboration)|대부분의 요구사항들과 개발 시스템에 대한 기본적인 아키텍처가 작성되는 단계|분석, 설계 관련 작업의 비중이 높다.|
|구축(Construction)|설계를 기반으로 시스템을 구축하는 단계|시스템을 구현하고 평가하는 작업의 비중이 높다.|
|이행(Transition)|제품의 완성 단계|설계, 구현, 평가활동의 비중이 높다. 사용자에게 제품을 인도한다.|

### 6. 애자일 방법론
#### (1) XP(익스트림 프로그래밍)
- 용기, 단순성, 의사소통, 피드백, 존중
- 요구사항은 스토리 카드에 기록되고, 릴리스마다 스토리의 상대적 우선순위가 결정된다.
- 기능이 구현되기 이전에 그 기능을 시험하기 위해 자동화된 단위시험 프레임워크를 이용한다.
- 모든 개발자들이 전체 코드에 대한 공동 책임을 가지며, 개발자 누구든지 어떤 코드라도 변경할 수 있다.
#### (2) Scrum(스크럼)
- 백로그(Backlog): 제품과 프로젝트에 대한 요구사항
- 스프린트(Sprint): 30일 단위의 짧은 개발기간으로 반복 수행



## **THEMA 87 프로젝트 관리**

## **THEMA 88 계획**
### 1. 노력 추정
#### (1) LOC (원시코드 라인수)
- 추정 LOC = ((낙관적 LOC)*1 + (중간치 LOC)*4 + (비관적 LOC)*1)) /6
- LOC = LOC / MM(man-month) * 프로그래머 명수(man) * 개발기간(month)

#### (2) COCOMO
- 단순형(5만 라인 이하) MM = 2.4 * LOC^1.05 * 노력조정수치
- 중간형(30만 라인 이하) MM = 3.0 * LOC^1.12 * 노력조정수치
- 내장형(30만 라인 이상) MM = 3.6 * LOC^1.20 * 노력조정수치

#### (3) 기능점수
- 시스템이 사용자에게 제공하는 기능을 기초로 응용 소프트웨어의 규모를 측정
- 소프트웨어 시스템이 가지는 기능을 정량화한 것
- 기능점수 산출 시 적용되는 가중치는 시스템의 특성에 따라 달라질 수 있다.
- 기능점수는 소프트웨어 개발 생명주기의 전체 단계에서 사용 가능하다.

### 2. 일정 계획
#### (1) WBS

#### (2) CPM

#### (3) 간트 차트



## **THEMA 89 위험 관리 프로세스**

## **THEMA 90 요구분석**
- what: 분석, how: 설계

### 1. 요구분석
#### (1) 신뢰도
- MTBF (Mean Time Between Failure)
- MTTF (Mean Time To Failure)
- MTTR (Mean Time To Repair)
- MTBF = MTTF + MTTR

#### (2) 가용도
- 이용도(가용도) = MTTF / (MTTF + MTTR) * 100(%)

### 2. 구조적 분석
- 문제를 기능적 관점의 프로세스로 나누고 프로세스에 어떤 입력 자료와 출력 자료가 필요한 지 고려한다
- 구조적 분석 도구: 자료 흐름도, 자료사전, 소단위 명세서

### 3 객체지향 분석
- 사용자의 기능적 관점을 파악하여 UML의 사용사례 다이어그램으로 나타낸다

#### (1) Use-Case Diagram
- 시스템의 기능을 나타내기 위하여 사용자의 요구를 추출하고 분석하는데 사용
- 컴퓨터 시스템을 사용할 때 사용자가 무엇을 하고 경험하는지를 글로 표현
- 포함(include)관계: 다른 사용 사례의 행동을 포함하는 경우, 기본 사용 사례에서 포함 사용 사례 방향
- 확장(extend)관계: 확장 사용 사례에서 기본 사용 사례 방향

### 4. 요구분석 명세서
- 무결성/완벽성
- 명확성
- 일관성
- 기능적
- 검증 가능성
- 추적 가능성

### 5. 요구공학 단계
- 타당성 조사 → 요구사항 추출 및 분석 → 요구사항 명세화 → 요구사항 검증



## **THEMA 91 설계**
### 1. 설계 종류
#### (1) 상위 설계
- 아키텍처 설계: 시스템의 전체적인 구조
- 사용자 인터페이스 설계: 사용자가 익숙하고 편리하게 사용할 수 있도록 설계

#### (2) 하위 설계
- 모듈 설계: 모듈 단위로 설계
- 알고리즘 설계: 각 모듈의 내부를 알고리즘 형태로 표현

### 2. 구조적 설계 도구
#### (1) 구조도
- 시스템 기능을 몇 개의 기능으로 분할하여 모듈로 나타내고, 모듈간의 인터페이스를 계층 구조로 표현한 도형

#### (2) HIPO
- 프로그램 논리의 문서화와 설계를 위해 도식적인 방법을 제공

#### (3) N-S Chart
- 논리 기술에 중점을 둔 도형식 표현 도구
- 순차, 선택, 반복의 3가지 제어구조를 표현
- 화살표나 GOTO문은 사용하지 않음

### 2. 소프트웨어 아키텍처
#### (1) 정의
- 외부에서 인식할 수 있는 특성을 가진 소프트웨어 구성요소들의 기본 구조
- 소프트웨어가 수행하는 여러 기능을 각 서브시스템 또는 컴포넌트에 적절히 할당하는 것

#### (2) 특징
- 의사소통 도구로 활용 가능
- 구현에 대한 제약사항을 정의
- 품질 속성을 결정
- 재사용 가능하게 설계



## **THEMA 92 UML(Unified Modeling Language)**

## **THEMA 93 디자인 패턴**
### 1. 생성 패턴
- 객체를 생성하는 것과 관련된 패턴
#### (1) Factory method
- 상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 한다.
- 생성자와는 별도로 객체 생성 메소드를 두어 기본 클래스로부터 파생클래스가 생성되게 한다.

#### (2) Singleton
- 객체를 하나만 생성하는 클래스를 정의

#### (3) Prototype

#### (4) Builder
- 복잡한 인스턴스를 조립하여 만드는 구조

#### (5) Abstraction Factory
- 객체 그룹의 추상화

### 2. 구조 패턴
- 프로그램 내의 자료구조나 인터페이스 구조 등 프로그램의 구조를 설계하는데 활용
#### (1) Composite
- 단일 객체와 복합 객체 모두 동일하게 다룬다.
- 기본 클래스와 이를 포함하는 컨테이너 클래스를 구분하지 않고 처리하는 재귀적 합성

#### (2) Adapter
- 기존 클래스를 재사용할 수 있게 인터페이스를 변환

#### (3) Bridge
- 구현과 추상화된 부분을 분리

#### (4) Decorator
- 기본 내용을 코어 객체로 하고 추가할 객체를 데코레이터로 만든 후 필요할 때 합성

#### (5) Facade
- 서브시스템의 내부가 복잡하여 클라이언트 코드가 사용하기 힘들 때

### 3. 행위 패턴
- 반복적으로 사용되는 객체들의 상호작용을 패턴화
#### (1) Template method
- 상위 클래스에서는 추상적으로 표현, 하위 클래스에서 구체적 내용 정의

#### (2) Iterator
- 반복이 필요한 자료구조를 모두 동일한 인터페이스를 통해 접근

#### (3) Observer
- 어떤 클래스에 변화가 일어났을 때 이를 감지하여 다른 클래스에 통보

#### (4) Strategy
- 알고리즘이 사용하는 곳과 알고리즘을 제공하는 곳을 분리
- 알고리즘을 동적으로 교체 가능

#### (5) Visitor
- 객체의 구조는 변경하지 않으면서 기능만 추가/확장

#### (6) Mediator
- 서로 관계된 객체의 수가 많아질 경우 복잡한 통신을 중간에서 통제하고 지시하는 역할



## **THEMA 94 모듈 설계**
### 1. 결합도(Coupling)
- 자료 결합도: 모듈들이 매개변수를 통해 데이터만 교환
- 스탬프 결합도: 데이터 구조를 매개변수로 사용
- 제어 결합도: 제어 플래그를 매개변수로 사용
- 외부 결합도: 시스템 범위 밖의 요소에 의존하는 경우
- 공통 결합도: 오듈들이 전역변수를 사용
- 내부 결합도: 모듈 간의 인터페이스를 사용하지 않고 직접 참조

### 2. 응집력(Cohesion)
- 기능적 응집도: 단일 기능의 요소로 하나의 모듈을 구성
- 순차적 응집도: 한 작업의 출력이 다른 작업의 입력으로 사용, 두 작업이 하나의 모듈을 구성
- 교환적 응집도: 같은 입력/같은 출력을 만드는 구성요소들을 하나의 모듈로 구성
- 절차적 응집도: 순서가 정해진 몇 개의 구성 요소를 하나의 모듈로 구성
- 시간적 응집도: 같은 시간대에 실행되는 요소를 하나의 모듈로 구성
- 논리적 응집도: 유사 성격 작업을 한 모듈로 구성
- 우연적 응집도: 아무 관계 X


