## **THEMA 85 소프트웨어 개발 생명주기(SDLC)**
### 1. 계획
#### (1) 비용계획
- LOC, COCOMO, 기능점수

#### (2) 일정계획
- WBS, CPM, PERT, 간트차트

### 2. 분석
#### (1) 기능적/비기능적 요구

#### (2) 구조적 분석도구
- 자료흐름도, 자료사전, 소단위 명세서

#### (3) 객체지향적 분석도구
- Use-Case Diagram

### 3. 설계
#### (1) 상위설계/하위설계
- 상위설계: 아키텍처 설계, 디자인 패턴
- 하위설계: 모듈 설계 (결합도, 응집력)

#### (2) 구조적 설계도구
- 구조도, HIPO, NS차트

#### (3) 객체지향적 설계도구 (UML)
- Sequence Diagram, Class Diagram, State Diagram

### 4. 구현
#### (1) 리팩토링

### 5. 테스트
#### (1) 정적테스트/동적테스트
- 동적테스트: 블랙박스 테스트, 화이트박스 테스트

#### (2)
단위 테스트 → 통합 테스트 → 시스템 테스트 → 인수 테스트  
+) JUnit: 단위 테스트 도구

### 6. 유지보수
- 수정 유지보수, 완전 유지보수, 적응 유지보수, 예방 유지보수
- 회귀 테스트



## **THEMA 86 소프트웨어 개발 방법론**
### 1. 폭포수 모형
### 2. 프로토타입 모형
### 3. 나선형 모형
- 대규모 프로젝트
- 계획 및 정의 → 위험 분석 → 개발(공학) → 고객 평가 단계를 반복

### 4. V 모형
- 요구분석 → 시스템설계 → 세부설계 → 구현 → 단위테스트 → 통합테스트 → 시스템테스트 → 인수/유지보수

### 5. 통합 프로세스 (UP: Unified Process)
#### (1) 특징
- 객체지향 소프트웨어 개발 방법론
- 반복적이고 점진적인 개발 방법
- use case 기반
- 아키텍처 중심의 개발 지향
- 위험 관리 중시

#### (2) 개발 활동
||||
|---|---|---|
|도입(Inception)|소프트웨어 개발에 관련된 사람들과 개발을 준비하는 단계|요구사항 관련 작업의 비중이 높다.|
|상세(Elaboration)|대부분의 요구사항들과 개발 시스템에 대한 기본적인 아키텍처가 작성되는 단계|분석, 설계 관련 작업의 비중이 높다.|
|구축(Construction)|설계를 기반으로 시스템을 구축하는 단계|시스템을 구현하고 평가하는 작업의 비중이 높다.|
|이행(Transition)|제품의 완성 단계|설계, 구현, 평가활동의 비중이 높다. 사용자에게 제품을 인도한다.|

### 6. 애자일 방법론
#### (1) XP(익스트림 프로그래밍)
- 용기, 단순성, 의사소통, 피드백, 존중
- 요구사항은 스토리 카드에 기록되고, 릴리스마다 스토리의 상대적 우선순위가 결정된다.
- 기능이 구현되기 이전에 그 기능을 시험하기 위해 자동화된 단위시험 프레임워크를 이용한다.
- 모든 개발자들이 전체 코드에 대한 공동 책임을 가지며, 개발자 누구든지 어떤 코드라도 변경할 수 있다.
#### (2) Scrum(스크럼)
- 백로그(Backlog): 제품과 프로젝트에 대한 요구사항
- 스프린트(Sprint): 30일 단위의 짧은 개발기간으로 반복 수행



## **THEMA 87 프로젝트 관리**

## **THEMA 88 계획**
### 1. 노력 추정
#### (1) LOC (원시코드 라인수)
- 추정 LOC = ((낙관적 LOC)*1 + (중간치 LOC)*4 + (비관적 LOC)*1)) /6
- LOC = LOC / MM(man-month) * 프로그래머 명수(man) * 개발기간(month)

#### (2) COCOMO
- 단순형(5만 라인 이하) MM = 2.4 * LOC^1.05 * 노력조정수치
- 중간형(30만 라인 이하) MM = 3.0 * LOC^1.12 * 노력조정수치
- 내장형(30만 라인 이상) MM = 3.6 * LOC^1.20 * 노력조정수치

#### (3) 기능점수
- 시스템이 사용자에게 제공하는 기능을 기초로 응용 소프트웨어의 규모를 측정
- 소프트웨어 시스템이 가지는 기능을 정량화한 것
- 기능점수 산출 시 적용되는 가중치는 시스템의 특성에 따라 달라질 수 있다.
- 기능점수는 소프트웨어 개발 생명주기의 전체 단계에서 사용 가능하다.

### 2. 일정 계획
#### (1) WBS

#### (2) CPM

#### (3) 간트 차트



## **THEMA 89 위험 관리 프로세스**

## **THEMA 90 요구분석**
- what: 분석, how: 설계

### 1. 요구분석
#### (1) 신뢰도
- MTBF (Mean Time Between Failure)
- MTTF (Mean Time To Failure)
- MTTR (Mean Time To Repair)
- MTBF = MTTF + MTTR

#### (2) 가용도
- 이용도(가용도) = MTTF / (MTTF + MTTR) * 100(%)

### 2. 구조적 분석
- 문제를 기능적 관점의 프로세스로 나누고 프로세스에 어떤 입력 자료와 출력 자료가 필요한 지 고려한다
- 구조적 분석 도구: 자료 흐름도, 자료사전, 소단위 명세서

### 3 객체지향 분석
- 사용자의 기능적 관점을 파악하여 UML의 사용사례 다이어그램으로 나타낸다

#### (1) Use-Case Diagram
- 시스템의 기능을 나타내기 위하여 사용자의 요구를 추출하고 분석하는데 사용
- 컴퓨터 시스템을 사용할 때 사용자가 무엇을 하고 경험하는지를 글로 표현
- 포함(include)관계: 다른 사용 사례의 행동을 포함하는 경우, 기본 사용 사례에서 포함 사용 사례 방향
- 확장(extend)관계: 확장 사용 사례에서 기본 사용 사례 방향

### 4. 요구분석 명세서
- 무결성/완벽성
- 명확성
- 일관성
- 기능적
- 검증 가능성
- 추적 가능성

### 5. 요구공학 단계
- 타당성 조사 → 요구사항 추출 및 분석 → 요구사항 명세화 → 요구사항 검증



## **THEMA 91 설계**
### 1. 설계 종류
#### (1) 상위 설계
- 아키텍처 설계: 시스템의 전체적인 구조
- 사용자 인터페이스 설계: 사용자가 익숙하고 편리하게 사용할 수 있도록 설계

#### (2) 하위 설계
- 모듈 설계: 모듈 단위로 설계
- 알고리즘 설계: 각 모듈의 내부를 알고리즘 형태로 표현

### 2. 구조적 설계 도구
#### (1) 구조도
- 시스템 기능을 몇 개의 기능으로 분할하여 모듈로 나타내고, 모듈간의 인터페이스를 계층 구조로 표현한 도형

#### (2) HIPO
- 프로그램 논리의 문서화와 설계를 위해 도식적인 방법을 제공

#### (3) N-S Chart
- 논리 기술에 중점을 둔 도형식 표현 도구
- 순차, 선택, 반복의 3가지 제어구조를 표현
- 화살표나 GOTO문은 사용하지 않음

### 2. 소프트웨어 아키텍처
#### (1) 정의
- 외부에서 인식할 수 있는 특성을 가진 소프트웨어 구성요소들의 기본 구조
- 소프트웨어가 수행하는 여러 기능을 각 서브시스템 또는 컴포넌트에 적절히 할당하는 것

#### (2) 특징
- 의사소통 도구로 활용 가능
- 구현에 대한 제약사항을 정의
- 품질 속성을 결정
- 재사용 가능하게 설계



## **THEMA 92 UML(Unified Modeling Language)**

## **THEMA 93 디자인 패턴**
### 1. 생성 패턴
- 객체를 생성하는 것과 관련된 패턴
#### (1) Factory method
- 상위 클래스에서 객체를 생성하는 인터페이스를 정의하고, 하위 클래스에서 인스턴스를 생성하도록 한다.
- 생성자와는 별도로 객체 생성 메소드를 두어 기본 클래스로부터 파생클래스가 생성되게 한다.

#### (2) Singleton
- 객체를 하나만 생성하는 클래스를 정의

#### (3) Prototype

#### (4) Builder
- 복잡한 인스턴스를 조립하여 만드는 구조

#### (5) Abstraction Factory
- 객체 그룹의 추상화

### 2. 구조 패턴
- 프로그램 내의 자료구조나 인터페이스 구조 등 프로그램의 구조를 설계하는데 활용
#### (1) Composite
- 단일 객체와 복합 객체 모두 동일하게 다룬다.
- 기본 클래스와 이를 포함하는 컨테이너 클래스를 구분하지 않고 처리하는 재귀적 합성

#### (2) Adapter
- 기존 클래스를 재사용할 수 있게 인터페이스를 변환

#### (3) Bridge
- 구현과 추상화된 부분을 분리

#### (4) Decorator
- 기본 내용을 코어 객체로 하고 추가할 객체를 데코레이터로 만든 후 필요할 때 합성

#### (5) Facade
- 서브시스템의 내부가 복잡하여 클라이언트 코드가 사용하기 힘들 때

### 3. 행위 패턴
- 반복적으로 사용되는 객체들의 상호작용을 패턴화
#### (1) Template method
- 상위 클래스에서는 추상적으로 표현, 하위 클래스에서 구체적 내용 정의

#### (2) Iterator
- 반복이 필요한 자료구조를 모두 동일한 인터페이스를 통해 접근

#### (3) Observer
- 어떤 클래스에 변화가 일어났을 때 이를 감지하여 다른 클래스에 통보

#### (4) Strategy
- 알고리즘이 사용하는 곳과 알고리즘을 제공하는 곳을 분리
- 알고리즘을 동적으로 교체 가능

#### (5) Visitor
- 객체의 구조는 변경하지 않으면서 기능만 추가/확장

#### (6) Mediator
- 서로 관계된 객체의 수가 많아질 경우 복잡한 통신을 중간에서 통제하고 지시하는 역할



## **THEMA 94 모듈 설계**
### 1. 결합도(Coupling)
- 자료 결합도: 모듈들이 매개변수를 통해 데이터만 교환
- 스탬프 결합도: 데이터 구조를 매개변수로 사용
- 제어 결합도: 제어 플래그를 매개변수로 사용
- 외부 결합도: 시스템 범위 밖의 요소에 의존하는 경우
- 공통 결합도: 오듈들이 전역변수를 사용
- 내부 결합도: 모듈 간의 인터페이스를 사용하지 않고 직접 참조

### 2. 응집력(Cohesion)
- 기능적 응집도: 단일 기능의 요소로 하나의 모듈을 구성
- 순차적 응집도: 한 작업의 출력이 다른 작업의 입력으로 사용, 두 작업이 하나의 모듈을 구성
- 교환적 응집도: 같은 입력/같은 출력을 만드는 구성요소들을 하나의 모듈로 구성
- 절차적 응집도: 순서가 정해진 몇 개의 구성 요소를 하나의 모듈로 구성
- 시간적 응집도: 같은 시간대에 실행되는 요소를 하나의 모듈로 구성
- 논리적 응집도: 유사 성격 작업을 한 모듈로 구성
- 우연적 응집도: 아무 관계 X



## **THEMA 95 객체지향 기본 개념**

## **THEMA 96 테스트**
### 1. 정적 테스트
- 프로그램 코드를 실행하지 않고 테스트
- walk-through, software inspection

### 2. 동적 테스트
#### (1) 블랙박스 테스트
- 프로그램 내부의 구조나 알고리즘을 보지 않고 테스트
- 동등 분할(Equivalence Partitioning): 테스트 대상의 입출력 값을 특정 클래스로 분할한 후, 각각의 클래스로부터 대푯값을 추출
- 경곗값 분석(Boundary Value Analysis): 동등 분할 기법을 확장시킨 것, 분할된 클래스의 경계에 대한 값까지 검사
- 인과 그래프(Cause-Effect Graph): 입력 데이터 간 관계가 출력에 영향을 미치는 상황을 분석하여 테스트 케이스 도출
- 비교 검사(Caomparison Test): Back-to-Back 시험, 소프트웨어의 신뢰성이 중요한 경우

#### (2) 화이트박스 테스트
- 프로그램 로직이나 코드 구조를 보며 테스트
- 문장 검증 기준(Statement Coverage): 프로그램 내의 모든 문장이 최소한 한 번은 실행되도록
- 분기 검증 기준(Branch Coverage): 원시코드에 존재하는 조건문에 대해 T/F
- 조건 검증 기준(Condition Coverage): 개별 조건식들에 대해서만 T/F
- 기본 경로 테스트(Basic Path Test): 원시코드의 독립적인 경로를 최소한 한 번은 실행되도록
- 자료 흐름 테스트(Data Flow Test): 프로그램 내의 데이터흐름을 중심으로 테스트


### 3. 테스트 수행 단계에 의한 분류
#### (1) 단위 테스트(Unit Test)
- 주로 화이트박스 테스트 기법 이용
- 상위 가상 모듈: 드라이버, 하위 가상 모듈: 스텁

#### (2) 통합 테스트(Integration Test)

#### (3) 시스템 테스트(System Test)

#### (4) 인수 테스트(Validation Test)
- 알파 테스트: 특정 사용자가 개발자 환경에서 테스트
- 베타 테스트: 최종 사용자가 사용자 환경에서 테스트



## **THEMA 97 유지보수/형상관리**
### 1. 유지보수
- 수정 유지보수: 검사 단계에서 발견하지 못한 오류를 찾아 수정
- 적응 유지보수: 환경 변화를 기존 SW에 반영
- 완전 유지보수: 새로운 기능 추가, 성능 개선
- 예방 유지보수: 미래에 유지보수를 용이하게 하기 위해

### 2. 소프트웨어 형상관리(SCM: Software Configuration Management)



## **THEMA 98 프로세스 품질 평가 모델**
### 1. ISO 12207

### 2. CMMI
|단계|프로세스|내용|
|---|---|---|
|초기 단계|X|예측&통제 불가능|
|관리 단계|규칙화된 프로세스|기본적 프로젝트 관리 체계 수립|
|정의 단계|표준화된 프로세스|조직 차원의 표준 프로세스를 통한 프로젝트 지원|
|정량적 단계|예측 가능한 프로세스|정량적으로 프로세스가 측정&통제|
|최적화 된계|지속적 개선 프로세스|프로세스 개선 활동|

### 3. SPICE (ISO 15504)
|레벨|단계|내용|
|---|---|---|
|레벨0|불완전 단계|미구현 또는 미달성|
|레벨1|수행 단계|프로세스 수행 및 목적 달성|
|레벨2|관리 단계|프로세스 수행 계획 및 관리|
|레벨3|확립 단계|정의된 표준 프로세스 사용|
|레벨4|예측 단계|프로세스의 정량적 이해 및 통제|
|레벨5|최적화 단계|프로세스를 지속적으로 개선|



## **THEMA 99 프로그래밍 언어**
### 1. 프로그래밍 패러다임
#### (1) 명령형 프로그래밍
- 명령의 순차적인 실행
- Cobol, Fortran, C, Ada, Perl

#### (2) 객체지향형 프로그래밍
- 상태를 변환시키는 메시지를 주고받으며 상호 교류하는 객체의 모임
- Smalltalk, C++, Java, C#, Objective-C

#### (3) 함수형 프로그래밍
- Lisp, Scheme

#### (4) 논리형 프로그래밍
- Prolog



## **THEMA 100 언어 번역**
### 1. 컴파일 기법
- 어휘 분석기(Lexical Analyzer) → 구문 분석기(Syntax Analyzer) → 중간 코드 생성기(Intermediate Code Generator) → 최적화(Optimization) → 코드 생성기(Code Generator)

- 링커(Linker): 여러 목적 모듈을 통합하여 실행 가능한 하나의 모듈로 변환
- 로더(Loader): 실행 가능한 모듈을 주기억장치에 적재, 할당/연결/재배치/적재 기능

### 2. 순수 해석(Pure Interpreter) 기법
- 실행시간이 매우 느리다.
- JavaScript

### 3. 하이브리드 기법
- Java
- 바이트 코드라 불리는 중간 코드로 번역, JVM(자바가상머신)이 바이트 코드 실행



## **THEMA 101 문법**
### 1. 촘스키 문법 분류
#### (1) Type 0: 무제한 문법

#### (2) Type 1: 문맥 의존 문법

#### (3) Type 2: 문맥 자유 문법
- 구문 분석: BNF(Backus-Naur Form), 파스트리, EBNF, 구문도표

#### (4) Type 3: 정규 문법
- 어휘분석: 정규식, 정규표현식, 유한오토마타



## **THEMA 102 C언어**
### 1. 연산자 우선순위
#### (1) 단항 연산자
- 단항 연산자: !(논리부정), ~(비트부정), ++, --, sizeof

#### (2) 이항 연산자
- 산술 연산자: *, /, %
- 산술 연산자: +, -
- 쉬프트 연산자: <<, >>
- 관계 연산자: <, <=, >=, >
- 비트논리 연산자: &, ^, |
- 논리 연산자, &&, ||

#### (3) 삼항 연산자
- 조건 연산자: ? :

#### (4) 대입 연산자
- 대입 연산자: =, +=, <<=, ..

#### (5) 콤마 연산자
- 콤마 연산자: ,


